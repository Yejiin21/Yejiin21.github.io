---
layout: post
title:  "QuickSort-003(self-study).md"
date:   2022-03-26 13:30:28 +0900
categories: jekyll update
---

# 퀵 정렬(Qucik Sort)

퀵 정렬은 분할 정복 알고리즘으로 분류되나, 사실 알고리즘이 수행되는 과정을 살펴보면 정복 후 분할하는 알고리즘이다.  
퀵 정렬 알고리즘은 문제를 2개의 부분문제로 분할하는데, 각 부분 문제의 크기가 일정하지 않은 형태의 분할 정복 알고리즘이다.

퀵 정렬의 아이디어는 **피봇(pivot)** 이라 일컫는 배열의 원소(숫자)를 기준으로 피봇보다 작은 숫자들은 왼편으로, 피봇보다 큰 숫자들은 오른편에 위치하도록 분할하고, 피봇을 그 사이에 놓는 것이다.   
*단, 주의할 점은 피봇은 분활된 왼편이나 오른편 부분에 포함되지 않는다*

퀵 정렬은 분활된 부분문제들에 대하여서도 위와 동일한 과정을 순환적으로 수행하여 정렬한다.   

![](https://postfiles.pstatic.net/MjAyMjAyMTBfMTU4/MDAxNjQ0NDcyNjU2ODUz.5V4yfg_QpEEi7eBnOS95DfnO683jonUKaMp9mWLjM6og.T0ASV2AGbTWoFZbC2fX9d0u7DdBXMX4o2eboYbSisiEg.GIF.agn710/quickSortAlgorithm.gif?type=w966)

위 그림에서 만일 피봇이 29라면, 29는 [5, 10, 14, 14, 2, 17]과 [41, 32, 37] 사이에 위치하며, 부분문제 [5, 10, 14, 14, 2, 17]과 [41, 32, 37]에 포함되지 않는다.

$$\dots$$

\<퀵 정복에 기반을 둔 합병 정렬 알고리즘\>
    
        QucikSort(A, left, right)
        입력 : 배열 A[left]~A[right]
        출력 : 정렬된 배열 A[left]~A[right]
    (1) if(left < right) {
    (2) 피봇을 A[left]~A[right] 중에서 선택하고, 피봇을 A[left]와 자리를 바꾼 후, 피봇과    
        배열의 각 원소를 비교하여 피봇보다 작은 숫자들은 A[left]~A[p-1]로 옮기고,피봇보다    
        큰 숫자들은 A[p+1]~A[right]로 옮기며, 피봇은 A[p]에 놓는다.   
    (3) QuickSort(A, left, p-1) //피봇보다 작은 그룹
    (4) QuickSort(A, p+1, right) //피봇보다 큰 그룹
        }

* Line 1에서는 배열 A의 가장 왼쪽 원소의 인덱스(left)가 가장 오른쪽 원소의 인덱스(right)보다 작으면, line 2-4에서 정렬을 수행한다. 만일 그렇지 않으면 left=right이므로, 더 이상 분할할 수 없는 크기, 즉 1개의 원소를 정렬하는 경우이다. 그러나 1개의 원소는 그 자체가 이미 정렬된 것이므로, line 2~4의 정렬 과정을 수행할 필요 없이 그대로 호출을 마친다.
* Line 2에서는 A[left]-A[right]에서 피봇을 선택하고, 배열 A[left]-A[right]의 원소들을 피봇과 각각 비교하여, 피봇보다 작은 그룹인 A[left]-A[p-1]과 피봇보다 큰 그룹인 A[p-1]~A[right]로 분할하고 피봇을 A[p]에 위치시킨다. 즉, p는 피봇이 위치하게 되는 배열 A의 인덱스이다.
* Line 3에서는 피봇보다 작은 그룹인 A[left]~A[p-1]을 순환적으로 호출한다.
* Line 4에서는 피봇보다 큰 숫자들은 A[p+1]~A[right]를 순환적으로 호출한다.

$$\dots$$

## QuickSort 알고리즘
   
1. QucikSort(A, 0, 8)
![](https://dbscthumb-phinf.pstatic.net/3523_000_1/20141020113635377_9H3WMM4G9.jpg/ka7_134_i1.jpg?type=w383_fst&wm=N)   
피봇은 A[1]=20으로 설정한다.

2. 피봇보다 큰 수와 피봇보다 작은 수를 다음과 같이 각각 교환한다.   
*피봇을 기준으로 오른쪽으로 이동하며 큰 데이터 값을 찾고 마지막 데이터(A[8])부터 왼쪽으로 이동하여 작은 데이터 값을 찾는다.*

    * 피봇보다 큰 50, 작은 5의 데이터 교환 
    ![](https://dbscthumb-phinf.pstatic.net/3523_000_1/20141020113635737_WCHFJ3TQP.jpg/ka7_134_i2.jpg?type=w431_fst&wm=N)
    * 피봇보다 큰 40, 작은 19의 데이터 교환
    ![](https://dbscthumb-phinf.pstatic.net/3523_000_1/20141020113636026_B5Z549GIU.jpg/ka7_134_i3.jpg?type=w431_fst&wm=N)

3. 마찬가지로 진행하여 피봇보다 큰 40, 작은 9의 데이터를 선택한다. **그런데 발견된 위치가 서로 교차하는데, 이러한 경우 두 값을 교환하지 않고 피봇 20과 작은 데이터인 9를 교환한다. 또한 기준키보다 큰 데이터를 발견하지 못하는 경우에도 피봇과 작은 데이터를 교환한다.**
![](https://dbscthumb-phinf.pstatic.net/3523_000_1/20141020113636532_97EATQHMY.jpg/ka7_134_i4.jpg?type=w431_fst&wm=N)

4. line 3에서 QuickSort(A, 0, 5-1) = QuickSort(A, 0, 4)이 호출되고, 그다음 line4에서 QuickSort(A, 5+1, 8) = QuickSort(A, 6, 8)이 호출된다.

5. QuickSort(A, 0, 4) 호출

    * 피봇 A[1] = 9라면 line 2에서 먼저 A[2]와 A[3]을 바꾼다.
    ![](https://dbscthumb-phinf.pstatic.net/3523_000_1/20141020113638267_ZP6RN3US0.jpg/ka7_134_i6.jpg?type=w431_fst&wm=N)

    * 마찬가지로 큰 데이터인 A[3] = 18과 작은 데이터인 A[2] = 5를 선택하는데, 발견된 위치가 교차되므로 피봇 9와 작은데이터 5를 교환한다.
    ![](https://dbscthumb-phinf.pstatic.net/3523_000_1/20141020113638539_UXLM1P3AD.jpg/ka7_134_i7.jpg?type=w431_fst&wm=N)

6. 이후에 QucikSort(A, 6, 8)이 호출되어 QuickSort 알고리즘이 수행되는데 위의 과정과 유사하므로 설명은 생략한다.

    ![](https://dbscthumb-phinf.pstatic.net/3523_000_1/20150831114420916_9N7U4TVE2.jpg/ka7_134_i13.jpg?type=w431_fst&wm=N)

    $$\dots$$

### QuickSort의 시간복잡도

퀵 정렬의 성능은 피봇 선택이 좌우한다. 피봇으로 가장 작은 숫자 또는 가장 큰 숫자가 선택되면, 한 부분으로 치우치는 분할을 야기한다.

* 평균적인 경우 : O(nlog₂n)

피봇이 입력을 2등분으로 분할하는 경우는 입력의 중앙값이 피봇으로 선택될 때이다. 

2등분으로 분할 할때마다 각각의 원소가 피봇과 1회씩 비교된다. 따라서 비교 횟수는 O(n)이다. 그러므로 총 비교 횟수는 O(n)*(층수) = O(n)*O(log₂n)이다.   
층수가 log₂n인 이유는 n/2=1일 때 k=log₂n이기 때문이다. 그러므로 퀵 정렬의 평균적인 시간복잡도는 O(nlog₂n)이다.

* 최악의 경우 : O(n^2)

정렬된 배열에서 바로 피봇을 최솟값이나 최댓값으로 선택한 경우에 가장 큰 시간이 소요됩니다.   
ex)   
정렬된 배열 [1, 2, 3, 4, 5, 6, 7]    
이 때, 1을 기준 값으로 선택하여 퀵정렬을 진행하면 L은 1에 , R은 7에 위치합니다.
먼저 7부터 1과 비교합니다.   
하지만 모든 데이터가 1보다 크기 때문에 L은 움직이지 않고 R이 L에게로 와서 1은 자기자리로 돌아가게 될 것입니다.   

그 다음 1은 정렬이 끝났으니 2를 기준 값으로 하게 됩니다.   
또 위와 같은 상황이 발생하게 되어 2 역기 자기자리로 돌아가게 됩니다.

만일 입력의 크기가 n이라면, 퀵 정렬의 최악 경우 시간복잡도는 (n-1)+(n-2)+(n-3)+...+2+1 = n(n-1)/2 = O(n^2)이다.


